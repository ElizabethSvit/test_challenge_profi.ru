## Задание 2. «Сокращатель ссылок»

Предположим, мы хотим написать свой собственный сокращатель ссылок (такой,
как bit.ly), и попросили вас написать API, который будет реализовывать
основную функциональность сервиса.

Для пользователя должны быть доступны следующие возможности:

1. Создать новую сокращенную ссылку (дать длинную, получить короткую)
2. Перейти по короткой ссылке и быть перенаправленным на исходную длинную ссылку
3. Просмотреть список «своих» ссылок, которые он сокращал
4. Просмотреть статистику переходов по каждой ссылке

## Решение

Для просмотра задания необходимо:

1. Установить MongoDB и запустить её (https://docs.mongodb.com/manual/administration/install-community/)
2. В папке "2" этого репозитория выполнить команду `npm install`
3. Запустить сервер с помощью команды `npm start`

### Команды

Приложение проверялось с помощью curl. 

- `curl --noproxy localhost -d "url=<валидная_ссылка>" -X POST http://localhost:4100/new` -- записывает новую ссылку в базу, если она валидная,
а также создает сокращенный "short_id" для этой ссылки (по дефолту выбрана длина 8) и возвращает пользователю json с оригинальной ссылкой и сокращенным id.
Алгоритм генерации сокращенного id для исходной ссылки это случайный выбор из обоих регистров английского алфавита и цифр заданой длины (по дефолту возможно 62 ^ 8 вариантов).
- `curl -v http://localhost:4100/<short_id>` -- возвращает данные страницы исходной ссылки, на которую пользователь был перенаправлен из short_id
- `curl -v http://localhost:4100/links` -- возвращает список всех ссылок, которые сокращал пользователь
- `curl -v http://localhost:4100/stats/<short_id>` -- возвращает json с short_id и количеством кликов по данной сокращенной ссылке

### Нагрузочное тестирование и оптимизация

Для нагрузочного тестирования основного сценария – открытия короткой ссылки и превращения ее в длинную был использован wrk.
Для того, чтобы наглядно увидеть разницу показателей wrk до и после тестирования, я добавила в базу 500000 ссылок вида `https://en.wikipedia.org/wiki/<i>`
c соответствующей сокращенной ссылкой вида `i`, где i пробегается от 1 до 500000.

Результаты по запросу для сценария до оптимизации:

```
wrk -t12 -c400 -d5s http://127.0.0.1:4100/1000

Running 5s test @ http://127.0.0.1:4100/1000
  12 threads and 400 connections
  Thread Stats   Avg      Stdev     Max   +/- Stdev
    Latency    50.07ms   15.33ms 100.68ms   67.26%
    Req/Sec   582.18     57.76     0.94k    76.00%
  34827 requests in 5.02s, 9.40MB read
  Socket errors: connect 0, read 276, write 0, timeout 0
Requests/sec:   6941.72
Transfer/sec:      1.87MB

```
Видно, что количество запросов, обрабатываемых сервером в секунду, примерно 7000, задержка около 50ms.

Так как в процессе открытия короткой ссылки и превращения ее в длинную происходит поиск по базе по short_id, то оптимизация может быть следующая: введем индекс по short_id, вместо дефолтного _id в mongo.

Результаты по запросу для сценария после оптимизации:

```
wrk -t12 -c400 -d5s http://127.0.0.1:4100/1000

Running 5s test @ http://127.0.0.1:4100/1000
  12 threads and 400 connections
  Thread Stats   Avg      Stdev     Max   +/- Stdev
    Latency    30.20ms    9.43ms  60.72ms   63.23%
    Req/Sec     0.86k   144.67     1.15k    70.67%
  51309 requests in 5.03s, 13.85MB read
  Socket errors: connect 0, read 294, write 0, timeout 0
Requests/sec:  10206.98
Transfer/sec:      2.75MB
```

Заметно улучшение по показателям кол-ва запросов сервера в секунду (~10200) и задержки в 30ms.

